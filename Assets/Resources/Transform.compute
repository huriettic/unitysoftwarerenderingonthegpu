#pragma kernel VertexTransform

#define MAX_TRIS 512

struct Triangle
{
    float2 v0;
    float2 v1;
    float2 v2;

    float2 uv0;
    float2 uv1;
    float2 uv2;

    float2 rwuv0;
    float2 rwuv1;
    float2 rwuv2;

    float rwz0;
    float rwz1;
    float rwz2;
    
    float rw0;
    float rw1;
    float rw2;

    float a0;
    float b0;
    float c0;

    float a1;
    float b1;
    float c1;

    float a2;
    float b2;
    float c2;

    float area;
    float rarea;
};

struct clipVertex
{
    float4 v;
    float2 uv;
    int b;
};

float4x4 view;
float4x4 proj;
float4x4 localToWorld;
int2 resolution;
int triangleCount;

RWStructuredBuffer<clipVertex> process;
RWStructuredBuffer<clipVertex> temporary;

StructuredBuffer<float3> vertices;
StructuredBuffer<float2> uvs;
StructuredBuffer<uint> indices;

RWStructuredBuffer<Triangle> trianglesWrite;
RWStructuredBuffer<uint> triangleCounter;

[numthreads(1, 1, 1)]
void VertexTransform(uint id : SV_DispatchThreadID)
{
    if (id >= (uint) triangleCount)
    {
        return;
    }
    
    float tinyNumber = 1e-6f;
    
    uint baseIndex = id * 256;

    uint i0 = indices[id * 3];
    uint i1 = indices[id * 3 + 1];
    uint i2 = indices[id * 3 + 2];

    float4 world0 = mul(localToWorld, float4(vertices[i0], 1));
    float4 world1 = mul(localToWorld, float4(vertices[i1], 1));
    float4 world2 = mul(localToWorld, float4(vertices[i2], 1));

    float4 view0 = mul(view, world0);
    float4 view1 = mul(view, world1);
    float4 view2 = mul(view, world2);

    float4 clip0 = mul(proj, view0);
    float4 clip1 = mul(proj, view1);
    float4 clip2 = mul(proj, view2);
    
    float2 ce1 = clip1.xy * clip0.w - clip0.xy * clip1.w;
    float2 ce2 = clip2.xy * clip0.w - clip0.xy * clip2.w;

    float clipDir = ce1.x * ce2.y - ce1.y * ce2.x;
    
    if (clipDir >= 0)
    {
        return;
    }

    int processcount = 0;
    
    process[baseIndex + processcount].v = clip0;
    process[baseIndex + processcount + 1].v = clip1;
    process[baseIndex + processcount + 2].v = clip2;
    process[baseIndex + processcount].uv = uvs[i0];
    process[baseIndex + processcount + 1].uv = uvs[i1];
    process[baseIndex + processcount + 2].uv = uvs[i2];
    process[baseIndex + processcount].b = 0;
    process[baseIndex + processcount + 1].b = 0;
    process[baseIndex + processcount + 2].b = 0;
    processcount += 3;

    for (int b = 0; b < 6; b++)
    {
        int addTriangles = 0;

        int temporarycount = 0;

        for (uint c = baseIndex; c < baseIndex + processcount; c += 3)
        {
            if (process[c].b == 1 && process[c + 1].b == 1 && process[c + 2].b == 1)
            {
                continue;
            }

            float4 v0 = process[c].v;
            float4 v1 = process[c + 1].v;
            float4 v2 = process[c + 2].v;

            float2 uv0 = process[c].uv;
            float2 uv1 = process[c + 1].uv;
            float2 uv2 = process[c + 2].uv;
            
            float d0, d1, d2;

            switch (b)
            {
                case 0: // Left: x >= -w
                    d0 = v0.x + v0.w;
                    d1 = v1.x + v1.w;
                    d2 = v2.x + v2.w;
                    break;

                case 1: // Right: x <= w
                    d0 = -v0.x + v0.w;
                    d1 = -v1.x + v1.w;
                    d2 = -v2.x + v2.w;
                    break;

                case 2: // Bottom: y >= -w
                    d0 = v0.y + v0.w;
                    d1 = v1.y + v1.w;
                    d2 = v2.y + v2.w;
                    break;

                case 3: // Top: y <= w
                    d0 = -v0.y + v0.w;
                    d1 = -v1.y + v1.w;
                    d2 = -v2.y + v2.w;
                    break;

                case 4: // Near: z >= 0 (Unity proj already handles API differences)
                    d0 = v0.z;
                    d1 = v1.z;
                    d2 = v2.z;
                    break;

                case 5: // Far: z <= w
                    d0 = -v0.z + v0.w;
                    d1 = -v1.z + v1.w;
                    d2 = -v2.z + v2.w;
                    break;
                
                default:
                    d0 = 0;
                    d1 = 0;
                    d2 = 0;
                    break;
            }

            bool b0 = d0 >= -tinyNumber;
            bool b1 = d1 >= -tinyNumber;
            bool b2 = d2 >= -tinyNumber;

            if (b0 && b1 && b2)
            {
                continue;
            }
            else if ((b0 && !b1 && !b2) || (!b0 && b1 && !b2) || (!b0 && !b1 && b2))
            {
                float4 inV, outV1, outV2;
                float2 inUV, outUV1, outUV2;
                float inD, outD1, outD2;

                if (b0)
                {
                    inV = v0;
                    inUV = uv0;
                    inD = d0;
                    outV1 = v1;
                    outUV1 = uv1;
                    outD1 = d1;
                    outV2 = v2;
                    outUV2 = uv2;
                    outD2 = d2;
                }
                else if (b1)
                {
                    inV = v1;
                    inUV = uv1;
                    inD = d1;
                    outV1 = v2;
                    outUV1 = uv2;
                    outD1 = d2;
                    outV2 = v0;
                    outUV2 = uv0;
                    outD2 = d0;
                }
                else
                {
                    inV = v2;
                    inUV = uv2;
                    inD = d2;
                    outV1 = v0;
                    outUV1 = uv0;
                    outD1 = d0;
                    outV2 = v1;
                    outUV2 = uv1;
                    outD2 = d1;
                }

                float t1 = inD / (inD - outD1);
                float t2 = inD / (inD - outD2);

                temporary[baseIndex + temporarycount].v = inV;
                temporary[baseIndex + temporarycount + 1].v = lerp(inV, outV1, t1);
                temporary[baseIndex + temporarycount + 2].v = lerp(inV, outV2, t2);
                temporary[baseIndex + temporarycount].uv = inUV;
                temporary[baseIndex + temporarycount + 1].uv = lerp(inUV, outUV1, t1);
                temporary[baseIndex + temporarycount + 2].uv = lerp(inUV, outUV2, t2);
                temporary[baseIndex + temporarycount].b = 0;
                temporary[baseIndex + temporarycount + 1].b = 0;
                temporary[baseIndex + temporarycount + 2].b = 0;
                temporarycount += 3;
                
                process[c].b = 1;
                process[c + 1].b = 1;
                process[c + 2].b = 1;
                
                addTriangles += 1;
            }
            else if ((!b0 && b1 && b2) || (b0 && !b1 && b2) || (b0 && b1 && !b2))
            {
                float4 inV1, inV2, outV;
                float2 inUV1, inUV2, outUV;
                float inD1, inD2, outD;

                if (!b0)
                {
                    outV = v0;
                    outUV = uv0;
                    outD = d0;
                    inV1 = v1;
                    inUV1 = uv1;
                    inD1 = d1;
                    inV2 = v2;
                    inUV2 = uv2;
                    inD2 = d2;
                }
                else if (!b1)
                {
                    outV = v1;
                    outUV = uv1;
                    outD = d1;
                    inV1 = v2;
                    inUV1 = uv2;
                    inD1 = d2;
                    inV2 = v0;
                    inUV2 = uv0;
                    inD2 = d0;
                }
                else
                {
                    outV = v2;
                    outUV = uv2;
                    outD = d2;
                    inV1 = v0;
                    inUV1 = uv0;
                    inD1 = d0;
                    inV2 = v1;
                    inUV2 = uv1;
                    inD2 = d1;
                }

                float t1 = inD1 / (inD1 - outD);
                float t2 = inD2 / (inD2 - outD);

                float4 vA = lerp(inV1, outV, t1);
                float4 vB = lerp(inV2, outV, t2);

                float2 uvA = lerp(inUV1, outUV, t1);
                float2 uvB = lerp(inUV2, outUV, t2);

                temporary[baseIndex + temporarycount].v = inV1;
                temporary[baseIndex + temporarycount + 1].v = inV2;
                temporary[baseIndex + temporarycount + 2].v = vA;
                temporary[baseIndex + temporarycount].uv = inUV1;
                temporary[baseIndex + temporarycount + 1].uv = inUV2;
                temporary[baseIndex + temporarycount + 2].uv = uvA;
                temporary[baseIndex + temporarycount].b = 0;
                temporary[baseIndex + temporarycount + 1].b = 0;
                temporary[baseIndex + temporarycount + 2].b = 0;
                temporarycount += 3;
                temporary[baseIndex + temporarycount].v = vA;
                temporary[baseIndex + temporarycount + 1].v = inV2;
                temporary[baseIndex + temporarycount + 2].v = vB;
                temporary[baseIndex + temporarycount].uv = uvA;
                temporary[baseIndex + temporarycount + 1].uv = inUV2;
                temporary[baseIndex + temporarycount + 2].uv = uvB;
                temporary[baseIndex + temporarycount].b = 0;
                temporary[baseIndex + temporarycount + 1].b = 0;
                temporary[baseIndex + temporarycount + 2].b = 0;
                temporarycount += 3;
                
                process[c].b = 1;
                process[c + 1].b = 1;
                process[c + 2].b = 1;

                addTriangles += 2;
            }
            else
            {
                process[c].b = 1;
                process[c + 1].b = 1;
                process[c + 2].b = 1;
            }
        }

        if (addTriangles > 0)
        {
            for (uint d = baseIndex; d < baseIndex + temporarycount; d += 3)
            {
                process[baseIndex + processcount] = temporary[d];
                process[baseIndex + processcount + 1] = temporary[d + 1];
                process[baseIndex + processcount + 2] = temporary[d + 2];
                processcount += 3;
            }
        }
    }

    for (uint e = baseIndex; e < baseIndex + processcount; e += 3)
    {
        if (process[e].b == 0 && process[e + 1].b == 0 && process[e + 2].b == 0)
        {
            float4 v0 = process[e].v;
            float4 v1 = process[e + 1].v;
            float4 v2 = process[e + 2].v;
        
            float2 t0 = process[e].uv;
            float2 t1 = process[e + 1].uv;
            float2 t2 = process[e + 2].uv;

            float invw0 = 1.0 / v0.w;
            float invw1 = 1.0 / v1.w;
            float invw2 = 1.0 / v2.w;
            
            float3 ndc0 = v0.xyz * invw0;
            float3 ndc1 = v1.xyz * invw1;
            float3 ndc2 = v2.xyz * invw2;
            
            float2 s0 = ((ndc0.xy * 0.5 + 0.5) * resolution);
            float2 s1 = ((ndc1.xy * 0.5 + 0.5) * resolution);
            float2 s2 = ((ndc2.xy * 0.5 + 0.5) * resolution);
            
            s1 = floor(s1) + 0.5;
            s0 = floor(s0) + 0.5;
            s2 = floor(s2) + 0.5;
            
            float2 se1 = s1 - s0;
            float2 se2 = s2 - s0;
            float a = se1.x * se2.y - se1.y * se2.x;
            
            if (abs(a) < 1e-8f)
            {
                continue;
            }
            
            float inva = 1.0 / a;
            
            Triangle tri;
        
            tri.v0 = s0;
            tri.v1 = s1;
            tri.v2 = s2;

            tri.rwz0 = v0.z * invw0;
            tri.rwz1 = v1.z * invw1;
            tri.rwz2 = v2.z * invw2;

            tri.uv0 = t0;
            tri.uv1 = t1;
            tri.uv2 = t2;

            tri.rwuv0 = t0 * invw0;
            tri.rwuv1 = t1 * invw1;
            tri.rwuv2 = t2 * invw2;

            tri.rw0 = invw0;
            tri.rw1 = invw1;
            tri.rw2 = invw2;
            
            tri.a0 = s1.y - s2.y;
            tri.b0 = -(s1.x - s2.x);
            tri.c0 = s1.x * s2.y - s1.y * s2.x;

            tri.a1 = s2.y - s0.y;
            tri.b1 = -(s2.x - s0.x);
            tri.c1 = s2.x * s0.y - s2.y * s0.x;

            tri.a2 = s0.y - s1.y;
            tri.b2 = -(s0.x - s1.x);
            tri.c2 = s0.x * s1.y - s0.y * s1.x;
            
            tri.area = a;
            tri.rarea = inva;
        
            uint triId;
            InterlockedAdd(triangleCounter[0], 1, triId);
            
            if (triId < MAX_TRIS)
            {
                trianglesWrite[triId] = tri;
            }
            else
            {
                continue;
            }
        }
    }
}