#pragma kernel VertexTransform

struct Triangle
{
    float2 v0;
    float2 v1;
    float2 v2;

    float2 uv0;
    float2 uv1;
    float2 uv2;

    float2 uvw0;
    float2 uvw1;
    float2 uvw2;

    float z0;
    float z1;
    float z2;
    
    float rw0;
    float rw1;
    float rw2;
    
    float w0;
    float w1;
    float w2;

    float A0;
    float B0;
    float C0;

    float A1;
    float B1;
    float C1;

    float A2;
    float B2;
    float C2;

    float area;
    float invArea;
};

float4x4 view;
float4x4 proj;
float4x4 localToWorld;
int2 resolution;
int triangleCount;

RWStructuredBuffer<float4> processVertices;
RWStructuredBuffer<float2> processTextures;
RWStructuredBuffer<int> processBool;
RWStructuredBuffer<float4> temporaryVertices;
RWStructuredBuffer<float2> temporaryTextures;

StructuredBuffer<float3> vertices;
StructuredBuffer<float2> uvs;
StructuredBuffer<uint> indices;

RWStructuredBuffer<Triangle> trianglesWrite;
RWStructuredBuffer<uint> triangleCounter;

[numthreads(1, 1, 1)]
void VertexTransform(uint id : SV_DispatchThreadID)
{
    if (id >= (uint) triangleCount)
    {
        return;
    }
    
    float tinyNumber = 1e-6f;
    
    uint baseIndex = id * 256;

    uint i0 = indices[id * 3];
    uint i1 = indices[id * 3 + 1];
    uint i2 = indices[id * 3 + 2];

    float4 world0 = mul(localToWorld, float4(vertices[i0], 1));
    float4 world1 = mul(localToWorld, float4(vertices[i1], 1));
    float4 world2 = mul(localToWorld, float4(vertices[i2], 1));

    float4 view0 = mul(view, world0);
    float4 view1 = mul(view, world1);
    float4 view2 = mul(view, world2);

    float4 clip0 = mul(proj, view0);
    float4 clip1 = mul(proj, view1);
    float4 clip2 = mul(proj, view2);
    
    float2 edge1 = clip1.xy * clip0.w - clip0.xy * clip1.w;
    float2 edge2 = clip2.xy * clip0.w - clip0.xy * clip2.w;

    float cross = edge1.x * edge2.y - edge1.y * edge2.x;
    
    if (cross >= 0)
    {
        return;
    }

    int processverticescount = 0;
    int processtexturescount = 0;
    int processboolcount = 0;

    processVertices[baseIndex + processverticescount] = clip0;
    processVertices[baseIndex + processverticescount + 1] = clip1;
    processVertices[baseIndex + processverticescount + 2] = clip2;
    processverticescount += 3;
    processTextures[baseIndex + processtexturescount] = uvs[i0];
    processTextures[baseIndex + processtexturescount + 1] = uvs[i1];
    processTextures[baseIndex + processtexturescount + 2] = uvs[i2];
    processtexturescount += 3;
    processBool[baseIndex + processboolcount] = 0;
    processBool[baseIndex + processboolcount + 1] = 0;
    processBool[baseIndex + processboolcount + 2] = 0;
    processboolcount += 3;

    for (int b = 0; b < 6; b++)
    {
        int addTriangles = 0;

        int temporaryverticescount = 0;
        int temporarytexturescount = 0;

        for (uint c = baseIndex; c < baseIndex + processverticescount; c += 3)
        {
            if (processBool[c] == 1 && processBool[c + 1] == 1 && processBool[c + 2] == 1)
            {
                continue;
            }

            float4 v0 = processVertices[c];
            float4 v1 = processVertices[c + 1];
            float4 v2 = processVertices[c + 2];

            float2 uv0 = processTextures[c];
            float2 uv1 = processTextures[c + 1];
            float2 uv2 = processTextures[c + 2];

            float d0, d1, d2;

            switch (b)
            {
                case 0: // Left: x >= -w
                    d0 = v0.x + v0.w;
                    d1 = v1.x + v1.w;
                    d2 = v2.x + v2.w;
                    break;

                case 1: // Right: x <= w
                    d0 = -v0.x + v0.w;
                    d1 = -v1.x + v1.w;
                    d2 = -v2.x + v2.w;
                    break;

                case 2: // Bottom: y >= -w
                    d0 = v0.y + v0.w;
                    d1 = v1.y + v1.w;
                    d2 = v2.y + v2.w;
                    break;

                case 3: // Top: y <= w
                    d0 = -v0.y + v0.w;
                    d1 = -v1.y + v1.w;
                    d2 = -v2.y + v2.w;
                    break;

                case 4: // Near: z >= 0 (Unity proj already handles API differences)
                    d0 = v0.z;
                    d1 = v1.z;
                    d2 = v2.z;
                    break;

                case 5: // Far: z <= w
                    d0 = -v0.z + v0.w;
                    d1 = -v1.z + v1.w;
                    d2 = -v2.z + v2.w;
                    break;
                
                default:
                    d0 = 0;
                    d1 = 0;
                    d2 = 0;
                    break;
            }

            bool b0 = d0 >= -tinyNumber;
            bool b1 = d1 >= -tinyNumber;
            bool b2 = d2 >= -tinyNumber;

            if (b0 && b1 && b2)
            {
                continue;
            }
            else if ((b0 && !b1 && !b2) || (!b0 && b1 && !b2) || (!b0 && !b1 && b2))
            {
                float4 inV, outV1, outV2;
                float2 inUV, outUV1, outUV2;
                float inD, outD1, outD2;

                if (b0)
                {
                    inV = v0;
                    inUV = uv0;
                    inD = d0;
                    outV1 = v1;
                    outUV1 = uv1;
                    outD1 = d1;
                    outV2 = v2;
                    outUV2 = uv2;
                    outD2 = d2;
                }
                else if (b1)
                {
                    inV = v1;
                    inUV = uv1;
                    inD = d1;
                    outV1 = v2;
                    outUV1 = uv2;
                    outD1 = d2;
                    outV2 = v0;
                    outUV2 = uv0;
                    outD2 = d0;
                }
                else
                {
                    inV = v2;
                    inUV = uv2;
                    inD = d2;
                    outV1 = v0;
                    outUV1 = uv0;
                    outD1 = d0;
                    outV2 = v1;
                    outUV2 = uv1;
                    outD2 = d1;
                }

                float t1 = inD / (inD - outD1);
                float t2 = inD / (inD - outD2);

                temporaryVertices[baseIndex + temporaryverticescount] = inV;
                temporaryVertices[baseIndex + temporaryverticescount + 1] = lerp(inV, outV1, t1);
                temporaryVertices[baseIndex + temporaryverticescount + 2] = lerp(inV, outV2, t2);
                temporaryverticescount += 3;
                temporaryTextures[baseIndex + temporarytexturescount] = inUV;
                temporaryTextures[baseIndex + temporarytexturescount + 1] = lerp(inUV, outUV1, t1);
                temporaryTextures[baseIndex + temporarytexturescount + 2] = lerp(inUV, outUV2, t2);
                temporarytexturescount += 3;
                processBool[c] = 1;
                processBool[c + 1] = 1;
                processBool[c + 2] = 1;

                addTriangles += 1;
            }
            else if ((!b0 && b1 && b2) || (b0 && !b1 && b2) || (b0 && b1 && !b2))
            {
                float4 inV1, inV2, outV;
                float2 inUV1, inUV2, outUV;
                float inD1, inD2, outD;

                if (!b0)
                {
                    outV = v0;
                    outUV = uv0;
                    outD = d0;
                    inV1 = v1;
                    inUV1 = uv1;
                    inD1 = d1;
                    inV2 = v2;
                    inUV2 = uv2;
                    inD2 = d2;
                }
                else if (!b1)
                {
                    outV = v1;
                    outUV = uv1;
                    outD = d1;
                    inV1 = v2;
                    inUV1 = uv2;
                    inD1 = d2;
                    inV2 = v0;
                    inUV2 = uv0;
                    inD2 = d0;
                }
                else
                {
                    outV = v2;
                    outUV = uv2;
                    outD = d2;
                    inV1 = v0;
                    inUV1 = uv0;
                    inD1 = d0;
                    inV2 = v1;
                    inUV2 = uv1;
                    inD2 = d1;
                }

                float t1 = inD1 / (inD1 - outD);
                float t2 = inD2 / (inD2 - outD);

                float4 vA = lerp(inV1, outV, t1);
                float4 vB = lerp(inV2, outV, t2);

                float2 uvA = lerp(inUV1, outUV, t1);
                float2 uvB = lerp(inUV2, outUV, t2);

                temporaryVertices[baseIndex + temporaryverticescount] = inV1;
                temporaryVertices[baseIndex + temporaryverticescount + 1] = inV2;
                temporaryVertices[baseIndex + temporaryverticescount + 2] = vA;
                temporaryverticescount += 3;
                temporaryTextures[baseIndex + temporarytexturescount] = inUV1;
                temporaryTextures[baseIndex + temporarytexturescount + 1] = inUV2;
                temporaryTextures[baseIndex + temporarytexturescount + 2] = uvA;
                temporarytexturescount += 3;
                temporaryVertices[baseIndex + temporaryverticescount] = vA;
                temporaryVertices[baseIndex + temporaryverticescount + 1] = inV2;
                temporaryVertices[baseIndex + temporaryverticescount + 2] = vB;
                temporaryverticescount += 3;
                temporaryTextures[baseIndex + temporarytexturescount] = uvA;
                temporaryTextures[baseIndex + temporarytexturescount + 1] = inUV2;
                temporaryTextures[baseIndex + temporarytexturescount + 2] = uvB;
                temporarytexturescount += 3;
                processBool[c] = 1;
                processBool[c + 1] = 1;
                processBool[c + 2] = 1;

                addTriangles += 2;
            }
            else
            {
                processBool[c] = 1;
                processBool[c + 1] = 1;
                processBool[c + 2] = 1;
            }
        }

        if (addTriangles > 0)
        {
            for (uint d = baseIndex; d < baseIndex + temporaryverticescount; d += 3)
            {
                processVertices[baseIndex + processverticescount] = temporaryVertices[d];
                processVertices[baseIndex + processverticescount + 1] = temporaryVertices[d + 1];
                processVertices[baseIndex + processverticescount + 2] = temporaryVertices[d + 2];
                processverticescount += 3;
                processTextures[baseIndex + processtexturescount] = temporaryTextures[d];
                processTextures[baseIndex + processtexturescount + 1] = temporaryTextures[d + 1];
                processTextures[baseIndex + processtexturescount + 2] = temporaryTextures[d + 2];
                processtexturescount += 3;
                processBool[baseIndex + processboolcount] = 0;
                processBool[baseIndex + processboolcount + 1] = 0;
                processBool[baseIndex + processboolcount + 2] = 0;
                processboolcount += 3;
            }
        }
    }

    for (uint e = baseIndex; e < baseIndex + processverticescount; e += 3)
    {
        if (processBool[e] == 0 && processBool[e + 1] == 0 && processBool[e + 2] == 0)
        {
            float4 c0 = processVertices[e];
            float4 c1 = processVertices[e + 1];
            float4 c2 = processVertices[e + 2];
        
            float2 t0 = processTextures[e];
            float2 t1 = processTextures[e + 1];
            float2 t2 = processTextures[e + 2];

            float invw0 = 1.0 / c0.w;
            float invw1 = 1.0 / c1.w;
            float invw2 = 1.0 / c2.w;

            float3 ndc0 = c0.xyz * invw0;
            float3 ndc1 = c1.xyz * invw1;
            float3 ndc2 = c2.xyz * invw2;

            float2 s0 = float2((ndc0.x * 0.5 + 0.5) * resolution.x, (ndc0.y * 0.5 + 0.5) * resolution.y);
            float2 s1 = float2((ndc1.x * 0.5 + 0.5) * resolution.x, (ndc1.y * 0.5 + 0.5) * resolution.y);
            float2 s2 = float2((ndc2.x * 0.5 + 0.5) * resolution.x, (ndc2.y * 0.5 + 0.5) * resolution.y);
        
            float2 e1v = s1 - s0;
            float2 e2v = s2 - s0;
            float area = e1v.x * e2v.y - e1v.y * e2v.x;
            
            if (area >= 0)
            {
                continue;
            }
            
            Triangle tri;
        
            tri.v0 = s0;
            tri.v1 = s1;
            tri.v2 = s2;

            tri.z0 = c0.z * invw0;
            tri.z1 = c1.z * invw1;
            tri.z2 = c2.z * invw2;

            tri.w0 = c0.w;
            tri.w1 = c1.w;
            tri.w2 = c2.w;

            tri.uv0 = t0;
            tri.uv1 = t1;
            tri.uv2 = t2;

            tri.uvw0 = t0 * invw0;
            tri.uvw1 = t1 * invw1;
            tri.uvw2 = t2 * invw2;

            tri.rw0 = invw0;
            tri.rw1 = invw1;
            tri.rw2 = invw2;
            
            tri.A0 = (s1.y - s2.y);
            tri.B0 = -(s1.x - s2.x);
            tri.C0 = (s1.x * s2.y - s1.y * s2.x);

            tri.A1 = (s2.y - s0.y);
            tri.B1 = -(s2.x - s0.x);
            tri.C1 = (s2.x * s0.y - s2.y * s0.x);

            tri.A2 = (s0.y - s1.y);
            tri.B2 = -(s0.x - s1.x);
            tri.C2 = (s0.x * s1.y - s0.y * s1.x);
            
            tri.area = area;
            tri.invArea = 1.0 / area;
        
            uint triId;
            InterlockedAdd(triangleCounter[0], 1, triId);
            trianglesWrite[triId] = tri;
        }
    }
}