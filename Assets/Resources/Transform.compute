#pragma kernel LocalTransform
#pragma kernel NDCTransform

#define MAX_TRIS 512

struct TriangleScreen
{
    float2 v0;
    float2 v1;
    float2 v2;

    float2 uv0;
    float2 uv1;
    float2 uv2;

    float2 rwuv0;
    float2 rwuv1;
    float2 rwuv2;

    float rwz0;
    float rwz1;
    float rwz2;
    
    float rw0;
    float rw1;
    float rw2;

    float a0;
    float b0;
    float c0;

    float a1;
    float b1;
    float c1;

    float a2;
    float b2;
    float c2;

    float area;
    float rarea;
};

struct TriangleNDC
{
    float3 v0;
    float3 v1;
    float3 v2;

    float2 uv0;
    float2 uv1;
    float2 uv2;

    float2 rwuv0;
    float2 rwuv1;
    float2 rwuv2;

    float rwz0;
    float rwz1;
    float rwz2;
    
    float rw0;
    float rw1;
    float rw2;
};

struct clipLocal
{
    float4 v;
    float2 uv;
    int b;
};

struct clipNDC
{
    float3 v;
    float2 uv;
    float2 rwuv;
    float rwz;
    float rw;
    int b;
};

float4x4 view;
float4x4 proj;
float4x4 localToWorld;
int2 resolution;
int triangleCount;

StructuredBuffer<float3> vertices;
StructuredBuffer<float2> uvs;
StructuredBuffer<uint> indices;

RWStructuredBuffer<clipLocal> processLocal;
RWStructuredBuffer<clipLocal> temporaryLocal;

RWStructuredBuffer<clipNDC> processNDC;
RWStructuredBuffer<clipNDC> temporaryNDC;

RWStructuredBuffer<uint> triangleNDCCounter;
RWStructuredBuffer<TriangleNDC> trianglesNDC;

RWStructuredBuffer<TriangleScreen> trianglesScreenWrite;
RWStructuredBuffer<uint> triangleScreenCounter;

[numthreads(1, 1, 1)]
void LocalTransform(uint id : SV_DispatchThreadID)
{
    if (id >= (uint) triangleCount)
    {
        return;
    }
    
    uint baseIndex = id * 256;

    uint i0 = indices[id * 3];
    uint i1 = indices[id * 3 + 1];
    uint i2 = indices[id * 3 + 2];

    float4 world0 = mul(localToWorld, float4(vertices[i0], 1));
    float4 world1 = mul(localToWorld, float4(vertices[i1], 1));
    float4 world2 = mul(localToWorld, float4(vertices[i2], 1));

    float4 view0 = mul(view, world0);
    float4 view1 = mul(view, world1);
    float4 view2 = mul(view, world2);

    float4 clip0 = mul(proj, view0);
    float4 clip1 = mul(proj, view1);
    float4 clip2 = mul(proj, view2);
    
    float2 ce1 = clip1.xy * clip0.w - clip0.xy * clip1.w;
    float2 ce2 = clip2.xy * clip0.w - clip0.xy * clip2.w;

    float clipDir = ce1.x * ce2.y - ce1.y * ce2.x;
    
    if (clipDir >= 0)
    {
        return;
    }

    int processcount = 0;
    
    processLocal[baseIndex + processcount].v = clip0;
    processLocal[baseIndex + processcount + 1].v = clip1;
    processLocal[baseIndex + processcount + 2].v = clip2;
    processLocal[baseIndex + processcount].uv = uvs[i0];
    processLocal[baseIndex + processcount + 1].uv = uvs[i1];
    processLocal[baseIndex + processcount + 2].uv = uvs[i2];
    processLocal[baseIndex + processcount].b = 0;
    processLocal[baseIndex + processcount + 1].b = 0;
    processLocal[baseIndex + processcount + 2].b = 0;
    processcount += 3;

    for (int b = 0; b < 6; b++)
    {
        int addTriangles = 0;
        int temporarycount = 0;

        for (uint c = baseIndex; c < baseIndex + processcount; c += 3)
        {
            if (processLocal[c].b == 1 && processLocal[c + 1].b == 1 && processLocal[c + 2].b == 1)
            {
                continue;
            }

            float4 v0 = processLocal[c].v;
            float4 v1 = processLocal[c + 1].v;
            float4 v2 = processLocal[c + 2].v;

            float2 uv0 = processLocal[c].uv;
            float2 uv1 = processLocal[c + 1].uv;
            float2 uv2 = processLocal[c + 2].uv;
            
            float d0, d1, d2;

            switch (b)
            {
                case 0: // Left: x >= -w
                    d0 = v0.x + v0.w;
                    d1 = v1.x + v1.w;
                    d2 = v2.x + v2.w;
                    break;

                case 1: // Right: x <= w
                    d0 = -v0.x + v0.w;
                    d1 = -v1.x + v1.w;
                    d2 = -v2.x + v2.w;
                    break;

                case 2: // Bottom: y >= -w
                    d0 = v0.y + v0.w;
                    d1 = v1.y + v1.w;
                    d2 = v2.y + v2.w;
                    break;

                case 3: // Top: y <= w
                    d0 = -v0.y + v0.w;
                    d1 = -v1.y + v1.w;
                    d2 = -v2.y + v2.w;
                    break;

                case 4: // Near: z >= 0 (Unity proj already handles API differences)
                    d0 = v0.z;
                    d1 = v1.z;
                    d2 = v2.z;
                    break;

                case 5: // Far: z <= w
                    d0 = -v0.z + v0.w;
                    d1 = -v1.z + v1.w;
                    d2 = -v2.z + v2.w;
                    break;
                
                default:
                    d0 = 0;
                    d1 = 0;
                    d2 = 0;
                    break;
            }

            bool b0 = d0 >= -1e-6f;
            bool b1 = d1 >= -1e-6f;
            bool b2 = d2 >= -1e-6f;

            if (b0 && b1 && b2)
            {
                continue;
            }
            else if ((b0 && !b1 && !b2) || (!b0 && b1 && !b2) || (!b0 && !b1 && b2))
            {
                float4 inV, outV1, outV2;
                float2 inUV, outUV1, outUV2;
                float inD, outD1, outD2;

                if (b0)
                {
                    inV = v0;
                    inUV = uv0;
                    inD = d0;
                    outV1 = v1;
                    outUV1 = uv1;
                    outD1 = d1;
                    outV2 = v2;
                    outUV2 = uv2;
                    outD2 = d2;
                }
                else if (b1)
                {
                    inV = v1;
                    inUV = uv1;
                    inD = d1;
                    outV1 = v2;
                    outUV1 = uv2;
                    outD1 = d2;
                    outV2 = v0;
                    outUV2 = uv0;
                    outD2 = d0;
                }
                else
                {
                    inV = v2;
                    inUV = uv2;
                    inD = d2;
                    outV1 = v0;
                    outUV1 = uv0;
                    outD1 = d0;
                    outV2 = v1;
                    outUV2 = uv1;
                    outD2 = d1;
                }

                float t1 = inD / (inD - outD1);
                float t2 = inD / (inD - outD2);

                temporaryLocal[baseIndex + temporarycount].v = inV;
                temporaryLocal[baseIndex + temporarycount + 1].v = lerp(inV, outV1, t1);
                temporaryLocal[baseIndex + temporarycount + 2].v = lerp(inV, outV2, t2);
                temporaryLocal[baseIndex + temporarycount].uv = inUV;
                temporaryLocal[baseIndex + temporarycount + 1].uv = lerp(inUV, outUV1, t1);
                temporaryLocal[baseIndex + temporarycount + 2].uv = lerp(inUV, outUV2, t2);
                temporaryLocal[baseIndex + temporarycount].b = 0;
                temporaryLocal[baseIndex + temporarycount + 1].b = 0;
                temporaryLocal[baseIndex + temporarycount + 2].b = 0;
                temporarycount += 3;
                
                processLocal[c].b = 1;
                processLocal[c + 1].b = 1;
                processLocal[c + 2].b = 1;
                
                addTriangles += 1;
            }
            else if ((!b0 && b1 && b2) || (b0 && !b1 && b2) || (b0 && b1 && !b2))
            {
                float4 inV1, inV2, outV;
                float2 inUV1, inUV2, outUV;
                float inD1, inD2, outD;

                if (!b0)
                {
                    outV = v0;
                    outUV = uv0;
                    outD = d0;
                    inV1 = v1;
                    inUV1 = uv1;
                    inD1 = d1;
                    inV2 = v2;
                    inUV2 = uv2;
                    inD2 = d2;
                }
                else if (!b1)
                {
                    outV = v1;
                    outUV = uv1;
                    outD = d1;
                    inV1 = v2;
                    inUV1 = uv2;
                    inD1 = d2;
                    inV2 = v0;
                    inUV2 = uv0;
                    inD2 = d0;
                }
                else
                {
                    outV = v2;
                    outUV = uv2;
                    outD = d2;
                    inV1 = v0;
                    inUV1 = uv0;
                    inD1 = d0;
                    inV2 = v1;
                    inUV2 = uv1;
                    inD2 = d1;
                }

                float t1 = inD1 / (inD1 - outD);
                float t2 = inD2 / (inD2 - outD);

                float4 vA = lerp(inV1, outV, t1);
                float4 vB = lerp(inV2, outV, t2);

                float2 uvA = lerp(inUV1, outUV, t1);
                float2 uvB = lerp(inUV2, outUV, t2);

                temporaryLocal[baseIndex + temporarycount].v = inV1;
                temporaryLocal[baseIndex + temporarycount + 1].v = inV2;
                temporaryLocal[baseIndex + temporarycount + 2].v = vA;
                temporaryLocal[baseIndex + temporarycount].uv = inUV1;
                temporaryLocal[baseIndex + temporarycount + 1].uv = inUV2;
                temporaryLocal[baseIndex + temporarycount + 2].uv = uvA;
                temporaryLocal[baseIndex + temporarycount].b = 0;
                temporaryLocal[baseIndex + temporarycount + 1].b = 0;
                temporaryLocal[baseIndex + temporarycount + 2].b = 0;
                temporarycount += 3;
                temporaryLocal[baseIndex + temporarycount].v = vA;
                temporaryLocal[baseIndex + temporarycount + 1].v = inV2;
                temporaryLocal[baseIndex + temporarycount + 2].v = vB;
                temporaryLocal[baseIndex + temporarycount].uv = uvA;
                temporaryLocal[baseIndex + temporarycount + 1].uv = inUV2;
                temporaryLocal[baseIndex + temporarycount + 2].uv = uvB;
                temporaryLocal[baseIndex + temporarycount].b = 0;
                temporaryLocal[baseIndex + temporarycount + 1].b = 0;
                temporaryLocal[baseIndex + temporarycount + 2].b = 0;
                temporarycount += 3;
                
                processLocal[c].b = 1;
                processLocal[c + 1].b = 1;
                processLocal[c + 2].b = 1;

                addTriangles += 2;
            }
            else
            {
                processLocal[c].b = 1;
                processLocal[c + 1].b = 1;
                processLocal[c + 2].b = 1;
            }
        }

        if (addTriangles > 0)
        {
            for (uint d = baseIndex; d < baseIndex + temporarycount; d += 3)
            {
                processLocal[baseIndex + processcount] = temporaryLocal[d];
                processLocal[baseIndex + processcount + 1] = temporaryLocal[d + 1];
                processLocal[baseIndex + processcount + 2] = temporaryLocal[d + 2];
                processcount += 3;
            }
        }
    }

    for (uint e = baseIndex; e < baseIndex + processcount; e += 3)
    {
        if (processLocal[e].b == 0 && processLocal[e + 1].b == 0 && processLocal[e + 2].b == 0)
        {
            float4 v0 = processLocal[e].v;
            float4 v1 = processLocal[e + 1].v;
            float4 v2 = processLocal[e + 2].v;
        
            float2 t0 = processLocal[e].uv;
            float2 t1 = processLocal[e + 1].uv;
            float2 t2 = processLocal[e + 2].uv;

            float invw0 = 1.0 / v0.w;
            float invw1 = 1.0 / v1.w;
            float invw2 = 1.0 / v2.w;
            
            float3 ndc0 = v0.xyz * invw0;
            float3 ndc1 = v1.xyz * invw1;
            float3 ndc2 = v2.xyz * invw2;
            
            TriangleNDC tri;
        
            tri.v0 = ndc0;
            tri.v1 = ndc1;
            tri.v2 = ndc2;

            tri.rwz0 = v0.z * invw0;
            tri.rwz1 = v1.z * invw1;
            tri.rwz2 = v2.z * invw2;

            tri.uv0 = t0;
            tri.uv1 = t1;
            tri.uv2 = t2;

            tri.rwuv0 = t0 * invw0;
            tri.rwuv1 = t1 * invw1;
            tri.rwuv2 = t2 * invw2;

            tri.rw0 = invw0;
            tri.rw1 = invw1;
            tri.rw2 = invw2;
        
            uint triId;
            InterlockedAdd(triangleNDCCounter[0], 1, triId);
            
            if (triId < MAX_TRIS)
            {
                trianglesNDC[triId] = tri;
            }
            else
            {
                continue;
            }
        }
    }
}

[numthreads(1, 1, 1)]
void NDCTransform(uint id : SV_DispatchThreadID)
{
    if (id >= triangleNDCCounter[0])
    {
        return;
    }
    
    float tinyNumber = 1e-6f;
    
    uint baseIndex = id * 256;
    
    TriangleNDC tri = trianglesNDC[id];
    
    int processcount = 0;

    processNDC[baseIndex + processcount].v = tri.v0;
    processNDC[baseIndex + processcount + 1].v = tri.v1;
    processNDC[baseIndex + processcount + 2].v = tri.v2;

    processNDC[baseIndex + processcount].uv = tri.uv0;
    processNDC[baseIndex + processcount + 1].uv = tri.uv1;
    processNDC[baseIndex + processcount + 2].uv = tri.uv2;

    processNDC[baseIndex + processcount].rwuv = tri.rwuv0;
    processNDC[baseIndex + processcount + 1].rwuv = tri.rwuv1;
    processNDC[baseIndex + processcount + 2].rwuv = tri.rwuv2;

    processNDC[baseIndex + processcount].rwz = tri.rwz0;
    processNDC[baseIndex + processcount + 1].rwz = tri.rwz1;
    processNDC[baseIndex + processcount + 2].rwz = tri.rwz2;

    processNDC[baseIndex + processcount].rw = tri.rw0;
    processNDC[baseIndex + processcount + 1].rw = tri.rw1;
    processNDC[baseIndex + processcount + 2].rw = tri.rw2;

    processNDC[baseIndex + processcount].b = 0;
    processNDC[baseIndex + processcount + 1].b = 0;
    processNDC[baseIndex + processcount + 2].b = 0;

    processcount += 3;
            
    for (int b = 0; b < 4; b++)
    {
        int addTriangles = 0;
        int temporarycount = 0;

        for (uint c = baseIndex; c < baseIndex + processcount; c += 3)
        {
            if (processNDC[c].b == 1 && processNDC[c + 1].b == 1 && processNDC[c + 2].b == 1)
                continue;

            float3 v0 = processNDC[c].v;
            float3 v1 = processNDC[c + 1].v;
            float3 v2 = processNDC[c + 2].v;

            float2 uv0 = processNDC[c].uv;
            float2 uv1 = processNDC[c + 1].uv;
            float2 uv2 = processNDC[c + 2].uv;

            float2 rwuv0 = processNDC[c].rwuv;
            float2 rwuv1 = processNDC[c + 1].rwuv;
            float2 rwuv2 = processNDC[c + 2].rwuv;

            float rwz0 = processNDC[c].rwz;
            float rwz1 = processNDC[c + 1].rwz;
            float rwz2 = processNDC[c + 2].rwz;

            float rw0 = processNDC[c].rw;
            float rw1 = processNDC[c + 1].rw;
            float rw2 = processNDC[c + 2].rw;

            float d0, d1, d2;

            switch (b)
            {
                case 0: // Left
                    d0 = v0.x - (-1.0);
                    d1 = v1.x - (-1.0);
                    d2 = v2.x - (-1.0);
                    break;

                case 1: // Right
                    d0 = 1.0 - v0.x;
                    d1 = 1.0 - v1.x;
                    d2 = 1.0 - v2.x;
                    break;

                case 2: // Bottom
                    d0 = v0.y - (-1.0);
                    d1 = v1.y - (-1.0);
                    d2 = v2.y - (-1.0);
                    break;

                case 3: // Top
                    d0 = 1.0 - v0.y;
                    d1 = 1.0 - v1.y;
                    d2 = 1.0 - v2.y;
                    break;

                default:
                    d0 = 0;
                    d1 = 0;
                    d2 = 0;
                    break;
            }

            bool b0 = d0 >= -1e-6f;
            bool b1 = d1 >= -1e-6f;
            bool b2 = d2 >= -1e-6f;

            if (b0 && b1 && b2)
            {
                continue;
            }
            else if ((b0 && !b1 && !b2) || (!b0 && b1 && !b2) || (!b0 && !b1 && b2))
            {
                float3 inV, outV1, outV2;
                float2 inUV, outUV1, outUV2;
                float2 inRWUV, outRWUV1, outRWUV2;
                float inRWZ, outRWZ1, outRWZ2;
                float inRW, outRW1, outRW2;

                float inD, outD1, outD2;

                if (b0)
                {
                    inV = v0;
                    inUV = uv0;
                    inRWUV = rwuv0;
                    inRWZ = rwz0;
                    inRW = rw0;
                    inD = d0;
                    outV1 = v1;
                    outUV1 = uv1;
                    outRWUV1 = rwuv1;
                    outRWZ1 = rwz1;
                    outRW1 = rw1;
                    outD1 = d1;
                    outV2 = v2;
                    outUV2 = uv2;
                    outRWUV2 = rwuv2;
                    outRWZ2 = rwz2;
                    outRW2 = rw2;
                    outD2 = d2;
                }
                else if (b1)
                {
                    inV = v1;
                    inUV = uv1;
                    inRWUV = rwuv1;
                    inRWZ = rwz1;
                    inRW = rw1;
                    inD = d1;
                    outV1 = v2;
                    outUV1 = uv2;
                    outRWUV1 = rwuv2;
                    outRWZ1 = rwz2;
                    outRW1 = rw2;
                    outD1 = d2;
                    outV2 = v0;
                    outUV2 = uv0;
                    outRWUV2 = rwuv0;
                    outRWZ2 = rwz0;
                    outRW2 = rw0;
                    outD2 = d0;
                }
                else
                {
                    inV = v2;
                    inUV = uv2;
                    inRWUV = rwuv2;
                    inRWZ = rwz2;
                    inRW = rw2;
                    inD = d2;
                    outV1 = v0;
                    outUV1 = uv0;
                    outRWUV1 = rwuv0;
                    outRWZ1 = rwz0;
                    outRW1 = rw0;
                    outD1 = d0;
                    outV2 = v1;
                    outUV2 = uv1;
                    outRWUV2 = rwuv1;
                    outRWZ2 = rwz1;
                    outRW2 = rw1;
                    outD2 = d1;
                }

                float t1 = inD / (inD - outD1);
                float t2 = inD / (inD - outD2);

                float3 vA = lerp(inV, outV1, t1);
                float3 vB = lerp(inV, outV2, t2);

                float2 uvA = lerp(inUV, outUV1, t1);
                float2 uvB = lerp(inUV, outUV2, t2);

                float2 rwuvA = lerp(inRWUV, outRWUV1, t1);
                float2 rwuvB = lerp(inRWUV, outRWUV2, t2);

                float rwzA = lerp(inRWZ, outRWZ1, t1);
                float rwzB = lerp(inRWZ, outRWZ2, t2);

                float rwA = lerp(inRW, outRW1, t1);
                float rwB = lerp(inRW, outRW2, t2);

                temporaryNDC[baseIndex + temporarycount].v = inV;
                temporaryNDC[baseIndex + temporarycount + 1].v = vA;
                temporaryNDC[baseIndex + temporarycount + 2].v = vB;
                temporaryNDC[baseIndex + temporarycount].uv = inUV;
                temporaryNDC[baseIndex + temporarycount + 1].uv = uvA;
                temporaryNDC[baseIndex + temporarycount + 2].uv = uvB;
                temporaryNDC[baseIndex + temporarycount].rwuv = inRWUV;
                temporaryNDC[baseIndex + temporarycount + 1].rwuv = rwuvA;
                temporaryNDC[baseIndex + temporarycount + 2].rwuv = rwuvB;
                temporaryNDC[baseIndex + temporarycount].rwz = inRWZ;
                temporaryNDC[baseIndex + temporarycount + 1].rwz = rwzA;
                temporaryNDC[baseIndex + temporarycount + 2].rwz = rwzB;
                temporaryNDC[baseIndex + temporarycount].rw = inRW;
                temporaryNDC[baseIndex + temporarycount + 1].rw = rwA;
                temporaryNDC[baseIndex + temporarycount + 2].rw = rwB;
                temporaryNDC[baseIndex + temporarycount].b = 0;
                temporaryNDC[baseIndex + temporarycount + 1].b = 0;
                temporaryNDC[baseIndex + temporarycount + 2].b = 0;
                temporarycount += 3;

                processNDC[c].b = 1;
                processNDC[c + 1].b = 1;
                processNDC[c + 2].b = 1;

                addTriangles += 1;
            }
            else if ((!b0 && b1 && b2) || (b0 && !b1 && b2) || (b0 && b1 && !b2))
            {
                float3 inV1, inV2, outV;
                float2 inUV1, inUV2, outUV;
                float2 inRWUV1, inRWUV2, outRWUV;
                float inRWZ1, inRWZ2, outRWZ;
                float inRW1, inRW2, outRW;

                float inD1, inD2, outD;

                if (!b0)
                {
                    outV = v0;
                    outUV = uv0;
                    outRWUV = rwuv0;
                    outRWZ = rwz0;
                    outRW = rw0;
                    outD = d0;
                    inV1 = v1;
                    inUV1 = uv1;
                    inRWUV1 = rwuv1;
                    inRWZ1 = rwz1;
                    inRW1 = rw1;
                    inD1 = d1;
                    inV2 = v2;
                    inUV2 = uv2;
                    inRWUV2 = rwuv2;
                    inRWZ2 = rwz2;
                    inRW2 = rw2;
                    inD2 = d2;
                }
                else if (!b1)
                {
                    outV = v1;
                    outUV = uv1;
                    outRWUV = rwuv1;
                    outRWZ = rwz1;
                    outRW = rw1;
                    outD = d1;
                    inV1 = v2;
                    inUV1 = uv2;
                    inRWUV1 = rwuv2;
                    inRWZ1 = rwz2;
                    inRW1 = rw2;
                    inD1 = d2;
                    inV2 = v0;
                    inUV2 = uv0;
                    inRWUV2 = rwuv0;
                    inRWZ2 = rwz0;
                    inRW2 = rw0;
                    inD2 = d0;
                }
                else
                {
                    outV = v2;
                    outUV = uv2;
                    outRWUV = rwuv2;
                    outRWZ = rwz2;
                    outRW = rw2;
                    outD = d2;
                    inV1 = v0;
                    inUV1 = uv0;
                    inRWUV1 = rwuv0;
                    inRWZ1 = rwz0;
                    inRW1 = rw0;
                    inD1 = d0;
                    inV2 = v1;
                    inUV2 = uv1;
                    inRWUV2 = rwuv1;
                    inRWZ2 = rwz1;
                    inRW2 = rw1;
                    inD2 = d1;
                }

                float t1 = inD1 / (inD1 - outD);
                float t2 = inD2 / (inD2 - outD);

                float3 vA = lerp(inV1, outV, t1);
                float3 vB = lerp(inV2, outV, t2);

                float2 uvA = lerp(inUV1, outUV, t1);
                float2 uvB = lerp(inUV2, outUV, t2);

                float2 rwuvA = lerp(inRWUV1, outRWUV, t1);
                float2 rwuvB = lerp(inRWUV2, outRWUV, t2);

                float rwzA = lerp(inRWZ1, outRWZ, t1);
                float rwzB = lerp(inRWZ2, outRWZ, t2);

                float rwA = lerp(inRW1, outRW, t1);
                float rwB = lerp(inRW2, outRW, t2);

                temporaryNDC[baseIndex + temporarycount].v = inV1;
                temporaryNDC[baseIndex + temporarycount + 1].v = inV2;
                temporaryNDC[baseIndex + temporarycount + 2].v = vA;
                temporaryNDC[baseIndex + temporarycount].uv = inUV1;
                temporaryNDC[baseIndex + temporarycount + 1].uv = inUV2;
                temporaryNDC[baseIndex + temporarycount + 2].uv = uvA;
                temporaryNDC[baseIndex + temporarycount].rwuv = inRWUV1;
                temporaryNDC[baseIndex + temporarycount + 1].rwuv = inRWUV2;
                temporaryNDC[baseIndex + temporarycount + 2].rwuv = rwuvA;
                temporaryNDC[baseIndex + temporarycount].rwz = inRWZ1;
                temporaryNDC[baseIndex + temporarycount + 1].rwz = inRWZ2;
                temporaryNDC[baseIndex + temporarycount + 2].rwz = rwzA;
                temporaryNDC[baseIndex + temporarycount].rw = inRW1;
                temporaryNDC[baseIndex + temporarycount + 1].rw = inRW2;
                temporaryNDC[baseIndex + temporarycount + 2].rw = rwA;
                temporaryNDC[baseIndex + temporarycount].b = 0;
                temporaryNDC[baseIndex + temporarycount + 1].b = 0;
                temporaryNDC[baseIndex + temporarycount + 2].b = 0;
                temporarycount += 3;
                temporaryNDC[baseIndex + temporarycount].v = vA;
                temporaryNDC[baseIndex + temporarycount + 1].v = inV2;
                temporaryNDC[baseIndex + temporarycount + 2].v = vB;
                temporaryNDC[baseIndex + temporarycount].uv = uvA;
                temporaryNDC[baseIndex + temporarycount + 1].uv = inUV2;
                temporaryNDC[baseIndex + temporarycount + 2].uv = uvB;
                temporaryNDC[baseIndex + temporarycount].rwuv = rwuvA;
                temporaryNDC[baseIndex + temporarycount + 1].rwuv = inRWUV2;
                temporaryNDC[baseIndex + temporarycount + 2].rwuv = rwuvB;
                temporaryNDC[baseIndex + temporarycount].rwz = rwzA;
                temporaryNDC[baseIndex + temporarycount + 1].rwz = inRWZ2;
                temporaryNDC[baseIndex + temporarycount + 2].rwz = rwzB;
                temporaryNDC[baseIndex + temporarycount].rw = rwA;
                temporaryNDC[baseIndex + temporarycount + 1].rw = inRW2;
                temporaryNDC[baseIndex + temporarycount + 2].rw = rwB;
                temporaryNDC[baseIndex + temporarycount].b = 0;
                temporaryNDC[baseIndex + temporarycount + 1].b = 0;
                temporaryNDC[baseIndex + temporarycount + 2].b = 0;
                temporarycount += 3;
                
                processNDC[c].b = 1;
                processNDC[c + 1].b = 1;
                processNDC[c + 2].b = 1;

                addTriangles += 2;
            }
            else
            {
                processNDC[c].b = 1;
                processNDC[c + 1].b = 1;
                processNDC[c + 2].b = 1;
            }
        }

        if (addTriangles > 0)
        {
            for (uint d = baseIndex; d < baseIndex + temporarycount; d += 3)
            {
                processNDC[baseIndex + processcount] = temporaryNDC[d];
                processNDC[baseIndex + processcount + 1] = temporaryNDC[d + 1];
                processNDC[baseIndex + processcount + 2] = temporaryNDC[d + 2];
                processcount += 3;
            }
        }
    }

    for (uint e = baseIndex; e < baseIndex + processcount; e += 3)
    {
        if (processNDC[e].b == 0 && processNDC[e + 1].b == 0 && processNDC[e + 2].b == 0)
        {
            float3 ndc0 = processNDC[e].v;
            float3 ndc1 = processNDC[e + 1].v;
            float3 ndc2 = processNDC[e + 2].v;
                    
            float2 s0 = ((ndc0.xy * 0.5 + 0.5) * resolution);
            float2 s1 = ((ndc1.xy * 0.5 + 0.5) * resolution);
            float2 s2 = ((ndc2.xy * 0.5 + 0.5) * resolution);
            
            s1 = floor(s1) + 0.5;
            s0 = floor(s0) + 0.5;
            s2 = floor(s2) + 0.5;
            
            float2 se1 = s1 - s0;
            float2 se2 = s2 - s0;
            float a = se1.x * se2.y - se1.y * se2.x;
            
            if (abs(a) < 1e-8f)
            {
                continue;
            }
            
            float inva = 1.0 / a;

            TriangleScreen outTri;

            outTri.v0 = s0;
            outTri.v1 = s1;
            outTri.v2 = s2;

            outTri.uv0 = processNDC[e].uv;
            outTri.uv1 = processNDC[e + 1].uv;
            outTri.uv2 = processNDC[e + 2].uv;

            outTri.rwuv0 = processNDC[e].rwuv;
            outTri.rwuv1 = processNDC[e + 1].rwuv;
            outTri.rwuv2 = processNDC[e + 2].rwuv;

            outTri.rwz0 = processNDC[e].rwz;
            outTri.rwz1 = processNDC[e + 1].rwz;
            outTri.rwz2 = processNDC[e + 2].rwz;

            outTri.rw0 = processNDC[e].rw;
            outTri.rw1 = processNDC[e + 1].rw;
            outTri.rw2 = processNDC[e + 2].rw;

            outTri.a0 = s1.y - s2.y;
            outTri.b0 = -(s1.x - s2.x);
            outTri.c0 = s1.x * s2.y - s1.y * s2.x;

            outTri.a1 = s2.y - s0.y;
            outTri.b1 = -(s2.x - s0.x);
            outTri.c1 = s2.x * s0.y - s2.y * s0.x;

            outTri.a2 = s0.y - s1.y;
            outTri.b2 = -(s0.x - s1.x);
            outTri.c2 = s0.x * s1.y - s0.y * s1.x;

            outTri.area = a;
            outTri.rarea = inva;
                    
            uint triId;
            InterlockedAdd(triangleScreenCounter[0], 1, triId);
            
            if (triId < MAX_TRIS)
            {
                trianglesScreenWrite[triId] = outTri;
            }
            else
            {
                continue;
            }
        }
    }
}