#pragma kernel TriangleBinning
#pragma kernel RasterizeTiles
#pragma kernel ClearRendering

#define TILE_WIDTH   8
#define TILE_HEIGHT  8

#define MAX_TRIS 512

struct Triangle
{
    float2 v0;
    float2 v1;
    float2 v2;

    float2 uv0;
    float2 uv1;
    float2 uv2;

    float2 uvw0;
    float2 uvw1;
    float2 uvw2;

    float z0;
    float z1;
    float z2;
    
    float rw0;
    float rw1;
    float rw2;
    
    float w0;
    float w1;
    float w2;

    float A0;
    float B0;
    float C0;

    float A1;
    float B1;
    float C1;

    float A2;
    float B2;
    float C2;

    float area;
    float invArea;
};

uint2 resolution;
uint tilesX;
uint tilesY;

StructuredBuffer<Triangle> trianglesRead;
StructuredBuffer<uint> triangleCounter;

RWStructuredBuffer<uint> tileWriteOffsets;
RWStructuredBuffer<uint> tileTriIndicesWrite;
StructuredBuffer<uint> tileTriIndicesRead;

RWTexture2D<float4> colorBuffer;
RWTexture2D<float> depthBuffer;

Texture2D<float4> _MainTex;
SamplerState sampler_MainTex;

[numthreads(1, 1, 1)]
void TriangleBinning(uint id : SV_DispatchThreadID)
{
    uint triCount = triangleCounter[0];
    
    if (id >= triCount)
    {
        return;
    }
    
    Triangle tri = trianglesRead[id];

    float2 minP = min(tri.v0, min(tri.v1, tri.v2));
    float2 maxP = max(tri.v0, max(tri.v1, tri.v2));

    int minTileX = clamp((int) floor(minP.x / TILE_WIDTH), 0, (int) tilesX - 1);
    int maxTileX = clamp((int) floor(maxP.x / TILE_WIDTH), 0, (int) tilesX - 1);
    int minTileY = clamp((int) floor(minP.y / TILE_HEIGHT), 0, (int) tilesY - 1);
    int maxTileY = clamp((int) floor(maxP.y / TILE_HEIGHT), 0, (int) tilesY - 1);

    for (int ty = minTileY; ty <= maxTileY; ty++)
    {
        for (int tx = minTileX; tx <= maxTileX; tx++)
        {
            uint tileIndex = ty * tilesX + tx;

            uint prevCount;
            InterlockedAdd(tileWriteOffsets[tileIndex], 1, prevCount);

            uint baseOffset = tileIndex * MAX_TRIS;
            
            tileTriIndicesWrite[baseOffset + prevCount] = id;
        }
    }
}

[numthreads(TILE_WIDTH, TILE_HEIGHT, 1)]
void RasterizeTiles(uint2 tid : SV_GroupThreadID, uint2 gid : SV_GroupID, uint2 did : SV_DispatchThreadID)
{
    uint tileIndex = gid.y * tilesX + gid.x;
    
    uint tileCount = tilesX * tilesY;
    
    if (tileIndex >= tileCount)
    {
        return;
    }
    
    uint count = tileWriteOffsets[tileIndex];
    
    if (count == 0)
    {
        return;
    }
    
    uint start = tileIndex * MAX_TRIS;

    uint tileX = tileIndex % tilesX;
    
    uint tileY = tileIndex / tilesX;

    int2 pixel = int2((int) (tileX * TILE_WIDTH + tid.x), (int) (tileY * TILE_HEIGHT + tid.y));

    if (pixel.x < 0 || pixel.y < 0 || pixel.x >= (int) resolution.x || pixel.y >= (int) resolution.y)
    {
        return;
    }

    float2 p = (float2) pixel + 0.5;

    float pixelZ = 1e9;
    
    float4 pixelCol = float4(0, 0, 0, 0);

    for (uint i = 0; i < count; i++)
    {
        Triangle tri = trianglesRead[tileTriIndicesRead[start + i]];

        float wp0 = tri.A0 * p.x + tri.B0 * p.y + tri.C0;
        float wp1 = tri.A1 * p.x + tri.B1 * p.y + tri.C1;
        float wp2 = tri.A2 * p.x + tri.B2 * p.y + tri.C2;

        if (wp0 > 1e-6f)
        {
            continue;
        }
        
        if (wp1 > 1e-6f)
        {
            continue;
        }
        
        if (wp2 > 1e-6f)
        {
            continue;
        }

        float b0 = wp0 * tri.invArea;
        float b1 = wp1 * tri.invArea;
        float b2 = wp2 * tri.invArea;

        float z = b0 * tri.z0 + b1 * tri.z1 + b2 * tri.z2;
        
        if (z >= pixelZ)
        {
            continue;
        }
        
        float denom = b0 * tri.rw0 + b1 * tri.rw1 + b2 * tri.rw2;
        
        float2 num = b0 * tri.uvw0 + b1 * tri.uvw1 + b2 * tri.uvw2;
        
        float2 uv = num / denom;

        pixelZ = z;
        pixelCol = _MainTex.SampleLevel(sampler_MainTex, uv, 0);
    }

    depthBuffer[pixel] = pixelZ;
    colorBuffer[pixel] = pixelCol;
}

[numthreads(TILE_WIDTH, TILE_HEIGHT, 1)]
void ClearRendering(uint2 tid : SV_GroupThreadID, uint2 gid : SV_GroupID, uint2 did : SV_DispatchThreadID)
{
    if (did.x < resolution.x && did.y < resolution.y)
    {
        colorBuffer[did] = float4(0, 0, 0, 1);
        depthBuffer[did] = 1e9;
    }

    if (tid.x == 0 && tid.y == 0)
    {
        uint tileIndex = gid.y * tilesX + gid.x;
        uint tileCount = tilesX * tilesY;

        if (tileIndex < tileCount)
        {
            tileWriteOffsets[tileIndex] = 0;
        }  
    }
}
