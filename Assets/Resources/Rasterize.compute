#pragma kernel TriangleBinning
#pragma kernel RasterizeTiles
#pragma kernel ClearRendering

#define TILE_WIDTH   8
#define TILE_HEIGHT  8

#define MAX_TRIS 512

struct Triangle
{
    float2 v0;
    float2 v1;
    float2 v2;

    float2 uv0;
    float2 uv1;
    float2 uv2;

    float2 rwuv0;
    float2 rwuv1;
    float2 rwuv2;

    float rwz0;
    float rwz1;
    float rwz2;
    
    float rw0;
    float rw1;
    float rw2;
    
    float w0;
    float w1;
    float w2;

    float a0;
    float b0;
    float c0;

    float a1;
    float b1;
    float c1;

    float a2;
    float b2;
    float c2;

    float area;
    float rarea;
};

uint2 resolution;
uint tilesX;
uint tilesY;

StructuredBuffer<Triangle> trianglesRead;
RWStructuredBuffer<uint> triangleCounter;

RWStructuredBuffer<uint> tileOffsets;
RWStructuredBuffer<uint> tileTriIndices;

RWTexture2D<float4> colorBuffer;
RWTexture2D<float> depthBuffer;

Texture2D<float4> _MainTex;
SamplerState sampler_MainTex;

[numthreads(TILE_WIDTH, TILE_HEIGHT, 1)]
void TriangleBinning(uint2 tid : SV_GroupThreadID, uint2 gid : SV_GroupID, uint2 did : SV_DispatchThreadID)
{
    uint tileIndex = gid.y * tilesX + gid.x;
    
    uint tileCount = tilesX * tilesY;
    
    if (tileIndex >= tileCount)
    {
        return;
    }

    float2 tileMin = float2(gid.x * TILE_WIDTH, gid.y * TILE_HEIGHT);
    float2 tileMax = tileMin + float2(TILE_WIDTH, TILE_HEIGHT);

    uint triCount = triangleCounter[0];

    uint threadIndex = tid.y * TILE_WIDTH + tid.x;
    uint threadCount = TILE_WIDTH * TILE_HEIGHT;

    for (uint id = threadIndex; id < triCount; id += threadCount)
    {
        Triangle tri = trianglesRead[id];

        float2 triMin = min(tri.v0, min(tri.v1, tri.v2));
        float2 triMax = max(tri.v0, max(tri.v1, tri.v2));

        if (triMax.x < tileMin.x || triMin.x >= tileMax.x || triMax.y < tileMin.y || triMin.y >= tileMax.y)
        {
            continue;
        }

        uint prevCount;
        InterlockedAdd(tileOffsets[tileIndex], 1, prevCount);

        if (prevCount < MAX_TRIS)
        {
            uint base = tileIndex * MAX_TRIS;
            tileTriIndices[base + prevCount] = id;
        }
        else
        {
            continue;
        }
    }
}

[numthreads(TILE_WIDTH, TILE_HEIGHT, 1)]
void RasterizeTiles(uint2 tid : SV_GroupThreadID, uint2 gid : SV_GroupID, uint2 did : SV_DispatchThreadID)
{
    uint tileIndex = gid.y * tilesX + gid.x;
    
    uint tileCount = tilesX * tilesY;
    
    if (tileIndex >= tileCount)
    {
        return;
    }
    
    uint count = min(tileOffsets[tileIndex], (uint) MAX_TRIS);
    
    if (count == 0)
    {
        return;
    }
    
    uint start = tileIndex * MAX_TRIS;
    
    if (did.x >= resolution.x || did.y >= resolution.y)
    {
        return;
    }

    float2 p = did + 0.5;

    float pixelZ = 1e9;
    
    float4 pixelCol = float4(0, 0, 0, 0);

    for (uint i = 0; i < count; i++)
    {
        Triangle tri = trianglesRead[tileTriIndices[start + i]];

        float wp0 = tri.a0 * p.x + tri.b0 * p.y + tri.c0;
        float wp1 = tri.a1 * p.x + tri.b1 * p.y + tri.c1;
        float wp2 = tri.a2 * p.x + tri.b2 * p.y + tri.c2;

        if (wp0 > 1e-6f || wp1 > 1e-6f || wp2 > 1e-6f)
        {
            continue;
        }

        float b0 = wp0 * tri.rarea;
        float b1 = wp1 * tri.rarea;
        float b2 = wp2 * tri.rarea;

        float z = b0 * tri.rwz0 + b1 * tri.rwz1 + b2 * tri.rwz2;
        
        if (z >= pixelZ)
        {
            continue;
        }
        
        float denom = b0 * tri.rw0 + b1 * tri.rw1 + b2 * tri.rw2;
        
        float2 num = b0 * tri.rwuv0 + b1 * tri.rwuv1 + b2 * tri.rwuv2;
        
        float2 uv = num / denom;

        pixelZ = z;
        pixelCol = _MainTex.SampleLevel(sampler_MainTex, uv, 0);
    }

    depthBuffer[did] = pixelZ;
    colorBuffer[did] = pixelCol;
}

[numthreads(TILE_WIDTH, TILE_HEIGHT, 1)]
void ClearRendering(uint2 tid : SV_GroupThreadID, uint2 gid : SV_GroupID, uint2 did : SV_DispatchThreadID)
{
    if (did.x < resolution.x && did.y < resolution.y)
    {
        colorBuffer[did] = float4(0, 0, 0, 1);
        depthBuffer[did] = 1e9;
    }

    if (tid.x == 0 && tid.y == 0)
    {
        uint tileIndex = gid.y * tilesX + gid.x;
        uint tileCount = tilesX * tilesY;

        if (tileIndex < tileCount)
        {
            tileOffsets[tileIndex] = 0;
        }  
    }
    
    if (gid.x == 0 && gid.y == 0 && tid.x == 0 && tid.y == 0)
    {
        triangleCounter[0] = 0;
    }
}
